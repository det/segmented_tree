<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>segmented_tree_seq: boost::container::segmented_tree_seq&lt; T, Allocator, segment_target, base_target &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">segmented_tree_seq
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>boost</b></li><li class="navelem"><b>container</b></li><li class="navelem"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">segmented_tree_seq</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classboost_1_1container_1_1segmented__tree__seq-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">boost::container::segmented_tree_seq&lt; T, Allocator, segment_target, base_target &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A segmented_tree_seq is a sequence container that provides efficient random access insert and erase.  
 <a href="classboost_1_1container_1_1segmented__tree__seq.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="segmented__tree__seq_8hpp_source.html">segmented_tree_seq.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a6f4abae8bb6c60675011914c5c4c1f40"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f4abae8bb6c60675011914c5c4c1f40"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a6f4abae8bb6c60675011914c5c4c1f40">value_type</a> = typename element_traits::value_type</td></tr>
<tr class="memdesc:a6f4abae8bb6c60675011914c5c4c1f40"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of elements stored in the container. <br /></td></tr>
<tr class="separator:a6f4abae8bb6c60675011914c5c4c1f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe7ffc37700e6030feaca9d5717848f7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe7ffc37700e6030feaca9d5717848f7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#abe7ffc37700e6030feaca9d5717848f7">allocator_type</a> = Allocator</td></tr>
<tr class="memdesc:abe7ffc37700e6030feaca9d5717848f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The allocator type used by the container. <br /></td></tr>
<tr class="separator:abe7ffc37700e6030feaca9d5717848f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c01867901b5c16949ba2377423b96f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86c01867901b5c16949ba2377423b96f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a86c01867901b5c16949ba2377423b96f">size_type</a> = typename element_traits::size_type</td></tr>
<tr class="memdesc:a86c01867901b5c16949ba2377423b96f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The unsigned integral type used by the container. <br /></td></tr>
<tr class="separator:a86c01867901b5c16949ba2377423b96f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e14c3a85bc42addd3b26a5c76e79794"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e14c3a85bc42addd3b26a5c76e79794"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a9e14c3a85bc42addd3b26a5c76e79794">difference_type</a> = typename element_traits::difference_type</td></tr>
<tr class="memdesc:a9e14c3a85bc42addd3b26a5c76e79794"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pointers difference type. <br /></td></tr>
<tr class="separator:a9e14c3a85bc42addd3b26a5c76e79794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c080ce5696a13d4496dfa62f19f53ce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c080ce5696a13d4496dfa62f19f53ce"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a5c080ce5696a13d4496dfa62f19f53ce">reference</a> = <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a6f4abae8bb6c60675011914c5c4c1f40">value_type</a> &amp;</td></tr>
<tr class="memdesc:a5c080ce5696a13d4496dfa62f19f53ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value reference type. <br /></td></tr>
<tr class="separator:a5c080ce5696a13d4496dfa62f19f53ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbcf64eda8f7e97d36f972cf63fcca6f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acbcf64eda8f7e97d36f972cf63fcca6f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#acbcf64eda8f7e97d36f972cf63fcca6f">const_reference</a> = <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a6f4abae8bb6c60675011914c5c4c1f40">value_type</a> const &amp;</td></tr>
<tr class="memdesc:acbcf64eda8f7e97d36f972cf63fcca6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value const reference type. <br /></td></tr>
<tr class="separator:acbcf64eda8f7e97d36f972cf63fcca6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff0a683914d037727598ac703ba505f1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff0a683914d037727598ac703ba505f1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#aff0a683914d037727598ac703ba505f1">pointer</a> = typename element_traits::pointer</td></tr>
<tr class="memdesc:aff0a683914d037727598ac703ba505f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pointer type. <br /></td></tr>
<tr class="separator:aff0a683914d037727598ac703ba505f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cdb9446ef0aef1ff231784c8b3a88ba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6cdb9446ef0aef1ff231784c8b3a88ba"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a6cdb9446ef0aef1ff231784c8b3a88ba">const_pointer</a> = typename element_traits::const_pointer</td></tr>
<tr class="memdesc:a6cdb9446ef0aef1ff231784c8b3a88ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const pointer type. <br /></td></tr>
<tr class="separator:a6cdb9446ef0aef1ff231784c8b3a88ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e7b87e6fcd753ce232c11088192d63e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e7b87e6fcd753ce232c11088192d63e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a8e7b87e6fcd753ce232c11088192d63e">iterator</a> = iterator_t&lt; <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#aff0a683914d037727598ac703ba505f1">pointer</a>, T &amp; &gt;</td></tr>
<tr class="memdesc:a8e7b87e6fcd753ce232c11088192d63e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The iterator type. <br /></td></tr>
<tr class="separator:a8e7b87e6fcd753ce232c11088192d63e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5bea87e824b662fd8dd7ea77b7c62fb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa5bea87e824b662fd8dd7ea77b7c62fb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#aa5bea87e824b662fd8dd7ea77b7c62fb">const_iterator</a> = iterator_t&lt; <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a6cdb9446ef0aef1ff231784c8b3a88ba">const_pointer</a>, T const &amp; &gt;</td></tr>
<tr class="memdesc:aa5bea87e824b662fd8dd7ea77b7c62fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const iterator type. <br /></td></tr>
<tr class="separator:aa5bea87e824b662fd8dd7ea77b7c62fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61182eb9ea0625c4c6f2e43dd316e0f5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a61182eb9ea0625c4c6f2e43dd316e0f5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a61182eb9ea0625c4c6f2e43dd316e0f5">reverse_iterator</a> = std::reverse_iterator&lt; <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a8e7b87e6fcd753ce232c11088192d63e">iterator</a> &gt;</td></tr>
<tr class="memdesc:a61182eb9ea0625c4c6f2e43dd316e0f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The reverse iterator type. <br /></td></tr>
<tr class="separator:a61182eb9ea0625c4c6f2e43dd316e0f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c5fb657f549f439cb7401c9de8c083"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a00c5fb657f549f439cb7401c9de8c083"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a00c5fb657f549f439cb7401c9de8c083">const_reverse_iterator</a> = std::reverse_iterator&lt; <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#aa5bea87e824b662fd8dd7ea77b7c62fb">const_iterator</a> &gt;</td></tr>
<tr class="memdesc:a00c5fb657f549f439cb7401c9de8c083"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const reverse iterator. <br /></td></tr>
<tr class="separator:a00c5fb657f549f439cb7401c9de8c083"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9cbf9f31953af034e5f31ce829e13a43"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a9cbf9f31953af034e5f31ce829e13a43">segmented_tree_seq</a> (Allocator const &amp;alloc)</td></tr>
<tr class="memdesc:a9cbf9f31953af034e5f31ce829e13a43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty sequence using the specified allocator.  <a href="#a9cbf9f31953af034e5f31ce829e13a43">More...</a><br /></td></tr>
<tr class="separator:a9cbf9f31953af034e5f31ce829e13a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d319a4a25a29e39e523b9ec9a31b5e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a30d319a4a25a29e39e523b9ec9a31b5e">segmented_tree_seq</a> () noexcept(               std::is_nothrow_default_constructible&lt; <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#abe7ffc37700e6030feaca9d5717848f7">allocator_type</a> &gt;::value)</td></tr>
<tr class="memdesc:a30d319a4a25a29e39e523b9ec9a31b5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructs an empty sequence.  <a href="#a30d319a4a25a29e39e523b9ec9a31b5e">More...</a><br /></td></tr>
<tr class="separator:a30d319a4a25a29e39e523b9ec9a31b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7944397dde9f0b1959bf67307fb8d44e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a7944397dde9f0b1959bf67307fb8d44e">segmented_tree_seq</a> (<a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a86c01867901b5c16949ba2377423b96f">size_type</a> count, T const &amp;value, Allocator const &amp;alloc=Allocator())</td></tr>
<tr class="memdesc:a7944397dde9f0b1959bf67307fb8d44e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a count size sequence using the specified allocator, each element copy constructed from value.  <a href="#a7944397dde9f0b1959bf67307fb8d44e">More...</a><br /></td></tr>
<tr class="separator:a7944397dde9f0b1959bf67307fb8d44e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2512f106644d962f4b50af2b7358303"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#ac2512f106644d962f4b50af2b7358303">segmented_tree_seq</a> (<a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a86c01867901b5c16949ba2377423b96f">size_type</a> count, Allocator const &amp;alloc=Allocator())</td></tr>
<tr class="memdesc:ac2512f106644d962f4b50af2b7358303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a count size sequence using the specified allocator, each element default constructed.  <a href="#ac2512f106644d962f4b50af2b7358303">More...</a><br /></td></tr>
<tr class="separator:ac2512f106644d962f4b50af2b7358303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e208324e2ac8d5a0fe3181ece537590"><td class="memTemplParams" colspan="2">template&lt;class InputIt , typename  = typename std::iterator_traits&lt;InputIt&gt;::pointer&gt; </td></tr>
<tr class="memitem:a9e208324e2ac8d5a0fe3181ece537590"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a9e208324e2ac8d5a0fe3181ece537590">segmented_tree_seq</a> (InputIt first, InputIt last, Allocator const &amp;alloc=Allocator())</td></tr>
<tr class="memdesc:a9e208324e2ac8d5a0fe3181ece537590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty sequence using the specified allocator, and inserts elements from the range [first, last).  <a href="#a9e208324e2ac8d5a0fe3181ece537590">More...</a><br /></td></tr>
<tr class="separator:a9e208324e2ac8d5a0fe3181ece537590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a972447e632b0a7784951359da5f7fbe7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a972447e632b0a7784951359da5f7fbe7">segmented_tree_seq</a> (<a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">segmented_tree_seq</a> const &amp;other)</td></tr>
<tr class="memdesc:a972447e632b0a7784951359da5f7fbe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructs a sequence.  <a href="#a972447e632b0a7784951359da5f7fbe7">More...</a><br /></td></tr>
<tr class="separator:a972447e632b0a7784951359da5f7fbe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d7eaef0f0f98e055896122c4d59a71"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a44d7eaef0f0f98e055896122c4d59a71">segmented_tree_seq</a> (<a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">segmented_tree_seq</a> const &amp;other, Allocator const &amp;alloc)</td></tr>
<tr class="memdesc:a44d7eaef0f0f98e055896122c4d59a71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructs a sequence using the specified allocator.  <a href="#a44d7eaef0f0f98e055896122c4d59a71">More...</a><br /></td></tr>
<tr class="separator:a44d7eaef0f0f98e055896122c4d59a71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc84aeec616e82babdaa7b4875c30186"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#afc84aeec616e82babdaa7b4875c30186">segmented_tree_seq</a> (<a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">segmented_tree_seq</a> &amp;&amp;other) noexcept(               std::is_nothrow_move_constructible&lt; <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#abe7ffc37700e6030feaca9d5717848f7">allocator_type</a> &gt;::value)</td></tr>
<tr class="memdesc:afc84aeec616e82babdaa7b4875c30186"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructs a sequence.  <a href="#afc84aeec616e82babdaa7b4875c30186">More...</a><br /></td></tr>
<tr class="separator:afc84aeec616e82babdaa7b4875c30186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16bf8a9a04f3377115bca46e3339dc16"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a16bf8a9a04f3377115bca46e3339dc16">segmented_tree_seq</a> (<a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">segmented_tree_seq</a> &amp;&amp;other, Allocator const &amp;alloc)</td></tr>
<tr class="memdesc:a16bf8a9a04f3377115bca46e3339dc16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructs a sequence using the specified allocator.  <a href="#a16bf8a9a04f3377115bca46e3339dc16">More...</a><br /></td></tr>
<tr class="separator:a16bf8a9a04f3377115bca46e3339dc16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf01f7c60dddce42f06ad18e02a3a1f6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#abf01f7c60dddce42f06ad18e02a3a1f6">segmented_tree_seq</a> (std::initializer_list&lt; T &gt; init, Allocator const &amp;alloc=Allocator())</td></tr>
<tr class="memdesc:abf01f7c60dddce42f06ad18e02a3a1f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty sequence using the specified allocator, and inserts elements from init.  <a href="#abf01f7c60dddce42f06ad18e02a3a1f6">More...</a><br /></td></tr>
<tr class="separator:abf01f7c60dddce42f06ad18e02a3a1f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a150e6370398c73554f47a8feedc064dd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a150e6370398c73554f47a8feedc064dd">~segmented_tree_seq</a> ()</td></tr>
<tr class="memdesc:a150e6370398c73554f47a8feedc064dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructs the sequence releasing all memory.  <a href="#a150e6370398c73554f47a8feedc064dd">More...</a><br /></td></tr>
<tr class="separator:a150e6370398c73554f47a8feedc064dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68f6b7b84d906997c0dfefcaf4324f4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">segmented_tree_seq</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a68f6b7b84d906997c0dfefcaf4324f4d">operator=</a> (<a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">segmented_tree_seq</a> const &amp;other)</td></tr>
<tr class="memdesc:a68f6b7b84d906997c0dfefcaf4324f4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assigns a sequence.  <a href="#a68f6b7b84d906997c0dfefcaf4324f4d">More...</a><br /></td></tr>
<tr class="separator:a68f6b7b84d906997c0dfefcaf4324f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a920e7ded8ef46598f63a1220ae1c452d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">segmented_tree_seq</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a920e7ded8ef46598f63a1220ae1c452d">operator=</a> (<a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">segmented_tree_seq</a> &amp;&amp;other) noexcept(               allocator_type::propagate_on_container_move_assignment::value                               &amp;&amp;std::is_nothrow_move_assignable&lt; <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#abe7ffc37700e6030feaca9d5717848f7">allocator_type</a> &gt;::value)</td></tr>
<tr class="memdesc:a920e7ded8ef46598f63a1220ae1c452d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assigns a sequence.  <a href="#a920e7ded8ef46598f63a1220ae1c452d">More...</a><br /></td></tr>
<tr class="separator:a920e7ded8ef46598f63a1220ae1c452d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26dd6958e87d105be3081fc529dc6db5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">segmented_tree_seq</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a26dd6958e87d105be3081fc529dc6db5">operator=</a> (std::initializer_list&lt; T &gt; ilist)</td></tr>
<tr class="memdesc:a26dd6958e87d105be3081fc529dc6db5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the sequence to count elements copy constructed from value.  <a href="#a26dd6958e87d105be3081fc529dc6db5">More...</a><br /></td></tr>
<tr class="separator:a26dd6958e87d105be3081fc529dc6db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58a00e1275976493e0d9de2a583b4d9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a58a00e1275976493e0d9de2a583b4d9f">assign</a> (<a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a86c01867901b5c16949ba2377423b96f">size_type</a> count, T const &amp;value)</td></tr>
<tr class="memdesc:a58a00e1275976493e0d9de2a583b4d9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the sequence to count elements copy constructed from value.  <a href="#a58a00e1275976493e0d9de2a583b4d9f">More...</a><br /></td></tr>
<tr class="separator:a58a00e1275976493e0d9de2a583b4d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a489f29272a6c8ab03b87ec38c891b"><td class="memTemplParams" colspan="2">template&lt;class InputIt , typename  = typename std::iterator_traits&lt;InputIt&gt;::pointer&gt; </td></tr>
<tr class="memitem:a00a489f29272a6c8ab03b87ec38c891b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a00a489f29272a6c8ab03b87ec38c891b">assign</a> (InputIt source_first, InputIt source_last)</td></tr>
<tr class="memdesc:a00a489f29272a6c8ab03b87ec38c891b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the sequence to the elements copy constructed from the range [first, last).  <a href="#a00a489f29272a6c8ab03b87ec38c891b">More...</a><br /></td></tr>
<tr class="separator:a00a489f29272a6c8ab03b87ec38c891b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f0d654ae1726a17e7c548ff98c85bce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a3f0d654ae1726a17e7c548ff98c85bce">assign</a> (std::initializer_list&lt; T &gt; ilist)</td></tr>
<tr class="memdesc:a3f0d654ae1726a17e7c548ff98c85bce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the sequence to the elements of the specified initializer_list.  <a href="#a3f0d654ae1726a17e7c548ff98c85bce">More...</a><br /></td></tr>
<tr class="separator:a3f0d654ae1726a17e7c548ff98c85bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e439edbba096a657869aac8c44577e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#abe7ffc37700e6030feaca9d5717848f7">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a1e439edbba096a657869aac8c44577e8">get_allocator</a> () const  noexcept</td></tr>
<tr class="memdesc:a1e439edbba096a657869aac8c44577e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the allocator for the sequence.  <a href="#a1e439edbba096a657869aac8c44577e8">More...</a><br /></td></tr>
<tr class="separator:a1e439edbba096a657869aac8c44577e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583b33cf66e8479658583accd35f196e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a5c080ce5696a13d4496dfa62f19f53ce">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a583b33cf66e8479658583accd35f196e">at</a> (<a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a86c01867901b5c16949ba2377423b96f">size_type</a> pos)</td></tr>
<tr class="memdesc:a583b33cf66e8479658583accd35f196e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference for the object located at the index pos.  <a href="#a583b33cf66e8479658583accd35f196e">More...</a><br /></td></tr>
<tr class="separator:a583b33cf66e8479658583accd35f196e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3848a61f645d90a0d0604b793ad5e35f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#acbcf64eda8f7e97d36f972cf63fcca6f">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a3848a61f645d90a0d0604b793ad5e35f">at</a> (<a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a86c01867901b5c16949ba2377423b96f">size_type</a> pos) const </td></tr>
<tr class="memdesc:a3848a61f645d90a0d0604b793ad5e35f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const_reference for the object located at the specified index pos.  <a href="#a3848a61f645d90a0d0604b793ad5e35f">More...</a><br /></td></tr>
<tr class="separator:a3848a61f645d90a0d0604b793ad5e35f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26b6812d0b9c99ae1275c8baed39fe4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a5c080ce5696a13d4496dfa62f19f53ce">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#ab26b6812d0b9c99ae1275c8baed39fe4">operator[]</a> (<a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a86c01867901b5c16949ba2377423b96f">size_type</a> pos)</td></tr>
<tr class="memdesc:ab26b6812d0b9c99ae1275c8baed39fe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference for the object located at the specified index pos.  <a href="#ab26b6812d0b9c99ae1275c8baed39fe4">More...</a><br /></td></tr>
<tr class="separator:ab26b6812d0b9c99ae1275c8baed39fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eed3246a332eef3c13a28fc0d138dd0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#acbcf64eda8f7e97d36f972cf63fcca6f">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a8eed3246a332eef3c13a28fc0d138dd0">operator[]</a> (<a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a86c01867901b5c16949ba2377423b96f">size_type</a> pos) const </td></tr>
<tr class="memdesc:a8eed3246a332eef3c13a28fc0d138dd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const_reference for the object located at the specified index pos.  <a href="#a8eed3246a332eef3c13a28fc0d138dd0">More...</a><br /></td></tr>
<tr class="separator:a8eed3246a332eef3c13a28fc0d138dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f68452c5f0befb302df3ce8c35c273d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a5c080ce5696a13d4496dfa62f19f53ce">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a6f68452c5f0befb302df3ce8c35c273d">front</a> ()</td></tr>
<tr class="memdesc:a6f68452c5f0befb302df3ce8c35c273d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference for the object located at the index 0.  <a href="#a6f68452c5f0befb302df3ce8c35c273d">More...</a><br /></td></tr>
<tr class="separator:a6f68452c5f0befb302df3ce8c35c273d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82e2b733fce99c20b31f29dd44150ce1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#acbcf64eda8f7e97d36f972cf63fcca6f">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a82e2b733fce99c20b31f29dd44150ce1">front</a> () const </td></tr>
<tr class="memdesc:a82e2b733fce99c20b31f29dd44150ce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const_reference for the object located at the index 0.  <a href="#a82e2b733fce99c20b31f29dd44150ce1">More...</a><br /></td></tr>
<tr class="separator:a82e2b733fce99c20b31f29dd44150ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a854fbfddb195e01e6606cce27387f7bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a5c080ce5696a13d4496dfa62f19f53ce">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a854fbfddb195e01e6606cce27387f7bb">back</a> ()</td></tr>
<tr class="memdesc:a854fbfddb195e01e6606cce27387f7bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference for the object located at the index size() - 1.  <a href="#a854fbfddb195e01e6606cce27387f7bb">More...</a><br /></td></tr>
<tr class="separator:a854fbfddb195e01e6606cce27387f7bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9826fe687a13982a55b3cb022d860829"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#acbcf64eda8f7e97d36f972cf63fcca6f">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a9826fe687a13982a55b3cb022d860829">back</a> () const </td></tr>
<tr class="memdesc:a9826fe687a13982a55b3cb022d860829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const_reference for the object located at the index size() - 1.  <a href="#a9826fe687a13982a55b3cb022d860829">More...</a><br /></td></tr>
<tr class="separator:a9826fe687a13982a55b3cb022d860829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e8c0fc6a97bb63e7c11d90c7cc270a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a8e7b87e6fcd753ce232c11088192d63e">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#aa2e8c0fc6a97bb63e7c11d90c7cc270a">begin</a> () noexcept</td></tr>
<tr class="memdesc:aa2e8c0fc6a97bb63e7c11d90c7cc270a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator for the index 0.  <a href="#aa2e8c0fc6a97bb63e7c11d90c7cc270a">More...</a><br /></td></tr>
<tr class="separator:aa2e8c0fc6a97bb63e7c11d90c7cc270a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e8f1484e21762efa317659d16914c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#aa5bea87e824b662fd8dd7ea77b7c62fb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a14e8f1484e21762efa317659d16914c4">begin</a> () const  noexcept</td></tr>
<tr class="memdesc:a14e8f1484e21762efa317659d16914c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const_iterator for the index 0.  <a href="#a14e8f1484e21762efa317659d16914c4">More...</a><br /></td></tr>
<tr class="separator:a14e8f1484e21762efa317659d16914c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac091db2869dcfb5fd6028e67e33b85ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#aa5bea87e824b662fd8dd7ea77b7c62fb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#ac091db2869dcfb5fd6028e67e33b85ee">cbegin</a> () const  noexcept</td></tr>
<tr class="memdesc:ac091db2869dcfb5fd6028e67e33b85ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const_iterator for the index 0.  <a href="#ac091db2869dcfb5fd6028e67e33b85ee">More...</a><br /></td></tr>
<tr class="separator:ac091db2869dcfb5fd6028e67e33b85ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67db6490da979e73b6f5ffe02ec53bdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a8e7b87e6fcd753ce232c11088192d63e">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a67db6490da979e73b6f5ffe02ec53bdb">penultimate</a> () noexcept</td></tr>
<tr class="memdesc:a67db6490da979e73b6f5ffe02ec53bdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the index size() - 1.  <a href="#a67db6490da979e73b6f5ffe02ec53bdb">More...</a><br /></td></tr>
<tr class="separator:a67db6490da979e73b6f5ffe02ec53bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319da7c983b0d4bcc7f1e8eb3511f82b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#aa5bea87e824b662fd8dd7ea77b7c62fb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a319da7c983b0d4bcc7f1e8eb3511f82b">penultimate</a> () const  noexcept</td></tr>
<tr class="memdesc:a319da7c983b0d4bcc7f1e8eb3511f82b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const_iterator to the index size() - 1.  <a href="#a319da7c983b0d4bcc7f1e8eb3511f82b">More...</a><br /></td></tr>
<tr class="separator:a319da7c983b0d4bcc7f1e8eb3511f82b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415ac3567b9c24a6e433e1ca41bd9089"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#aa5bea87e824b662fd8dd7ea77b7c62fb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a415ac3567b9c24a6e433e1ca41bd9089">cpenultimate</a> () const  noexcept</td></tr>
<tr class="memdesc:a415ac3567b9c24a6e433e1ca41bd9089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const_iterator to the index size() - 1.  <a href="#a415ac3567b9c24a6e433e1ca41bd9089">More...</a><br /></td></tr>
<tr class="separator:a415ac3567b9c24a6e433e1ca41bd9089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf454cb608ccba75ceff1a78e82a1a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a8e7b87e6fcd753ce232c11088192d63e">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#abcf454cb608ccba75ceff1a78e82a1a8">end</a> () noexcept</td></tr>
<tr class="memdesc:abcf454cb608ccba75ceff1a78e82a1a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator for the index size().  <a href="#abcf454cb608ccba75ceff1a78e82a1a8">More...</a><br /></td></tr>
<tr class="separator:abcf454cb608ccba75ceff1a78e82a1a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a342650aa64a6a2e1b3f6eae4a3343149"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#aa5bea87e824b662fd8dd7ea77b7c62fb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a342650aa64a6a2e1b3f6eae4a3343149">end</a> () const  noexcept</td></tr>
<tr class="memdesc:a342650aa64a6a2e1b3f6eae4a3343149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const_iterator for the index size().  <a href="#a342650aa64a6a2e1b3f6eae4a3343149">More...</a><br /></td></tr>
<tr class="separator:a342650aa64a6a2e1b3f6eae4a3343149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa063813ca250438066c4b00db1c6360f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#aa5bea87e824b662fd8dd7ea77b7c62fb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#aa063813ca250438066c4b00db1c6360f">cend</a> () const  noexcept</td></tr>
<tr class="memdesc:aa063813ca250438066c4b00db1c6360f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const_iterator for the index size().  <a href="#aa063813ca250438066c4b00db1c6360f">More...</a><br /></td></tr>
<tr class="separator:aa063813ca250438066c4b00db1c6360f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c505a59a968f6935c082a7978416da4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a61182eb9ea0625c4c6f2e43dd316e0f5">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a9c505a59a968f6935c082a7978416da4">rbegin</a> () noexcept</td></tr>
<tr class="memdesc:a9c505a59a968f6935c082a7978416da4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse_iterator for the index size().  <a href="#a9c505a59a968f6935c082a7978416da4">More...</a><br /></td></tr>
<tr class="separator:a9c505a59a968f6935c082a7978416da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23e29690e43f7dd6a5d1c32ddc3f7406"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a00c5fb657f549f439cb7401c9de8c083">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a23e29690e43f7dd6a5d1c32ddc3f7406">rbegin</a> () const  noexcept</td></tr>
<tr class="memdesc:a23e29690e43f7dd6a5d1c32ddc3f7406"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const_reverse_iterator for the index size().  <a href="#a23e29690e43f7dd6a5d1c32ddc3f7406">More...</a><br /></td></tr>
<tr class="separator:a23e29690e43f7dd6a5d1c32ddc3f7406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a004d94988016bcbeab7a52088649b9fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a00c5fb657f549f439cb7401c9de8c083">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a004d94988016bcbeab7a52088649b9fd">crbegin</a> () const  noexcept</td></tr>
<tr class="memdesc:a004d94988016bcbeab7a52088649b9fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const_reverse_iterator for the index size().  <a href="#a004d94988016bcbeab7a52088649b9fd">More...</a><br /></td></tr>
<tr class="separator:a004d94988016bcbeab7a52088649b9fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ef8f17fb622f5f9cd1e085c041d165"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a61182eb9ea0625c4c6f2e43dd316e0f5">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a14ef8f17fb622f5f9cd1e085c041d165">rend</a> () noexcept</td></tr>
<tr class="memdesc:a14ef8f17fb622f5f9cd1e085c041d165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse_iterator for the index 0.  <a href="#a14ef8f17fb622f5f9cd1e085c041d165">More...</a><br /></td></tr>
<tr class="separator:a14ef8f17fb622f5f9cd1e085c041d165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c53450a3514d9186071d205a44449d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a00c5fb657f549f439cb7401c9de8c083">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#aa6c53450a3514d9186071d205a44449d">rend</a> () const  noexcept</td></tr>
<tr class="memdesc:aa6c53450a3514d9186071d205a44449d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const_reverse_iterator for the index 0.  <a href="#aa6c53450a3514d9186071d205a44449d">More...</a><br /></td></tr>
<tr class="separator:aa6c53450a3514d9186071d205a44449d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4389882226b3cae4fee967e4537fc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a00c5fb657f549f439cb7401c9de8c083">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#afd4389882226b3cae4fee967e4537fc1">crend</a> () const  noexcept</td></tr>
<tr class="memdesc:afd4389882226b3cae4fee967e4537fc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const_reverse_iterator for the index 0.  <a href="#afd4389882226b3cae4fee967e4537fc1">More...</a><br /></td></tr>
<tr class="separator:afd4389882226b3cae4fee967e4537fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5db65e75657ba3ea2f67121cf0d25f2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a8e7b87e6fcd753ce232c11088192d63e">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a5db65e75657ba3ea2f67121cf0d25f2e">nth</a> (<a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a86c01867901b5c16949ba2377423b96f">size_type</a> pos) noexcept</td></tr>
<tr class="memdesc:a5db65e75657ba3ea2f67121cf0d25f2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator for the index pos.  <a href="#a5db65e75657ba3ea2f67121cf0d25f2e">More...</a><br /></td></tr>
<tr class="separator:a5db65e75657ba3ea2f67121cf0d25f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29554e93abc87ad6a98a9da53d2bb84b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#aa5bea87e824b662fd8dd7ea77b7c62fb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a29554e93abc87ad6a98a9da53d2bb84b">nth</a> (<a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a86c01867901b5c16949ba2377423b96f">size_type</a> pos) const  noexcept</td></tr>
<tr class="memdesc:a29554e93abc87ad6a98a9da53d2bb84b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const_iterator for the index pos.  <a href="#a29554e93abc87ad6a98a9da53d2bb84b">More...</a><br /></td></tr>
<tr class="separator:a29554e93abc87ad6a98a9da53d2bb84b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50862ae43a026cb5369070d0cdad8dc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a86c01867901b5c16949ba2377423b96f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a50862ae43a026cb5369070d0cdad8dc7">index_of</a> (<a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a8e7b87e6fcd753ce232c11088192d63e">iterator</a> pos) noexcept</td></tr>
<tr class="memdesc:a50862ae43a026cb5369070d0cdad8dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the specified iterator.  <a href="#a50862ae43a026cb5369070d0cdad8dc7">More...</a><br /></td></tr>
<tr class="separator:a50862ae43a026cb5369070d0cdad8dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ef0b30f070fe072c85e818debb5a44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a86c01867901b5c16949ba2377423b96f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a37ef0b30f070fe072c85e818debb5a44">index_of</a> (<a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#aa5bea87e824b662fd8dd7ea77b7c62fb">const_iterator</a> pos) const  noexcept</td></tr>
<tr class="memdesc:a37ef0b30f070fe072c85e818debb5a44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the specified const_iterator.  <a href="#a37ef0b30f070fe072c85e818debb5a44">More...</a><br /></td></tr>
<tr class="separator:a37ef0b30f070fe072c85e818debb5a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f9b817e2cc7924a450cb61054e1146"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#ab7f9b817e2cc7924a450cb61054e1146">empty</a> () const  noexcept</td></tr>
<tr class="memdesc:ab7f9b817e2cc7924a450cb61054e1146"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the sequence is empty, false otherwise.  <a href="#ab7f9b817e2cc7924a450cb61054e1146">More...</a><br /></td></tr>
<tr class="separator:ab7f9b817e2cc7924a450cb61054e1146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a933ca7e0417f7d9819a9fb5b23dc4f21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a86c01867901b5c16949ba2377423b96f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a933ca7e0417f7d9819a9fb5b23dc4f21">size</a> () const  noexcept</td></tr>
<tr class="memdesc:a933ca7e0417f7d9819a9fb5b23dc4f21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the count of elements stored in the sequence.  <a href="#a933ca7e0417f7d9819a9fb5b23dc4f21">More...</a><br /></td></tr>
<tr class="separator:a933ca7e0417f7d9819a9fb5b23dc4f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f1f90b102dd7dbe12ab197ac145abee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a86c01867901b5c16949ba2377423b96f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a0f1f90b102dd7dbe12ab197ac145abee">height</a> () const  noexcept</td></tr>
<tr class="memdesc:a0f1f90b102dd7dbe12ab197ac145abee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the height of the tree.  <a href="#a0f1f90b102dd7dbe12ab197ac145abee">More...</a><br /></td></tr>
<tr class="separator:a0f1f90b102dd7dbe12ab197ac145abee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c13c5039297dcf513a6276652f00abf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a86c01867901b5c16949ba2377423b96f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a7c13c5039297dcf513a6276652f00abf">max_size</a> () const  noexcept</td></tr>
<tr class="memdesc:a7c13c5039297dcf513a6276652f00abf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum count of elements able to be stored in the sequence.  <a href="#a7c13c5039297dcf513a6276652f00abf">More...</a><br /></td></tr>
<tr class="separator:a7c13c5039297dcf513a6276652f00abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f9dc208a664f0753a148e93f68a7f39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a0f9dc208a664f0753a148e93f68a7f39">clear</a> () noexcept</td></tr>
<tr class="memdesc:a0f9dc208a664f0753a148e93f68a7f39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements from the sequence.  <a href="#a0f9dc208a664f0753a148e93f68a7f39">More...</a><br /></td></tr>
<tr class="separator:a0f9dc208a664f0753a148e93f68a7f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1f4986b73cb15f68d473c3d1f12f399"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a8e7b87e6fcd753ce232c11088192d63e">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#ae1f4986b73cb15f68d473c3d1f12f399">insert</a> (<a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#aa5bea87e824b662fd8dd7ea77b7c62fb">const_iterator</a> pos, T const &amp;value)</td></tr>
<tr class="memdesc:ae1f4986b73cb15f68d473c3d1f12f399"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructs an object at the specified position.  <a href="#ae1f4986b73cb15f68d473c3d1f12f399">More...</a><br /></td></tr>
<tr class="separator:ae1f4986b73cb15f68d473c3d1f12f399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f6a4ad55d3cdfe8f907ea7b9b1cba6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a8e7b87e6fcd753ce232c11088192d63e">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a61f6a4ad55d3cdfe8f907ea7b9b1cba6">insert</a> (<a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#aa5bea87e824b662fd8dd7ea77b7c62fb">const_iterator</a> pos, T &amp;&amp;value)</td></tr>
<tr class="memdesc:a61f6a4ad55d3cdfe8f907ea7b9b1cba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move construct an object at the specified position.  <a href="#a61f6a4ad55d3cdfe8f907ea7b9b1cba6">More...</a><br /></td></tr>
<tr class="separator:a61f6a4ad55d3cdfe8f907ea7b9b1cba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9176dfa87acd53a3485bec3733ae368a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a8e7b87e6fcd753ce232c11088192d63e">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a9176dfa87acd53a3485bec3733ae368a">insert</a> (<a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#aa5bea87e824b662fd8dd7ea77b7c62fb">const_iterator</a> pos, <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a86c01867901b5c16949ba2377423b96f">size_type</a> count, T const &amp;value)</td></tr>
<tr class="memdesc:a9176dfa87acd53a3485bec3733ae368a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy construct count elements at the specified position.  <a href="#a9176dfa87acd53a3485bec3733ae368a">More...</a><br /></td></tr>
<tr class="separator:a9176dfa87acd53a3485bec3733ae368a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2440645f49fee33b9104ed9e78744795"><td class="memTemplParams" colspan="2">template&lt;class InputIt , typename  = typename std::iterator_traits&lt;InputIt&gt;::pointer&gt; </td></tr>
<tr class="memitem:a2440645f49fee33b9104ed9e78744795"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a8e7b87e6fcd753ce232c11088192d63e">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a2440645f49fee33b9104ed9e78744795">insert</a> (<a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#aa5bea87e824b662fd8dd7ea77b7c62fb">const_iterator</a> pos, InputIt first, InputIt last)</td></tr>
<tr class="memdesc:a2440645f49fee33b9104ed9e78744795"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructs all elements in the range [first, last) at the specified position.  <a href="#a2440645f49fee33b9104ed9e78744795">More...</a><br /></td></tr>
<tr class="separator:a2440645f49fee33b9104ed9e78744795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d25190e454da4d597f9ee05feca343"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a8e7b87e6fcd753ce232c11088192d63e">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#ac9d25190e454da4d597f9ee05feca343">insert</a> (<a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#aa5bea87e824b662fd8dd7ea77b7c62fb">const_iterator</a> pos, std::initializer_list&lt; T &gt; ilist)</td></tr>
<tr class="memdesc:ac9d25190e454da4d597f9ee05feca343"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructs all elements in the specified initializer_list at the specified position.  <a href="#ac9d25190e454da4d597f9ee05feca343">More...</a><br /></td></tr>
<tr class="separator:ac9d25190e454da4d597f9ee05feca343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d6d23ad18f64aafdf5f9bc37a7971ae"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a2d6d23ad18f64aafdf5f9bc37a7971ae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a8e7b87e6fcd753ce232c11088192d63e">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a2d6d23ad18f64aafdf5f9bc37a7971ae">emplace</a> (<a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#aa5bea87e824b662fd8dd7ea77b7c62fb">const_iterator</a> pos, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a2d6d23ad18f64aafdf5f9bc37a7971ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward constructs an object at the specified position.  <a href="#a2d6d23ad18f64aafdf5f9bc37a7971ae">More...</a><br /></td></tr>
<tr class="separator:a2d6d23ad18f64aafdf5f9bc37a7971ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6307735b88b83ab9c22c0d92ddc66140"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a8e7b87e6fcd753ce232c11088192d63e">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a6307735b88b83ab9c22c0d92ddc66140">erase</a> (<a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#aa5bea87e824b662fd8dd7ea77b7c62fb">const_iterator</a> pos)</td></tr>
<tr class="memdesc:a6307735b88b83ab9c22c0d92ddc66140"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the object at the specified position from the sequence.  <a href="#a6307735b88b83ab9c22c0d92ddc66140">More...</a><br /></td></tr>
<tr class="separator:a6307735b88b83ab9c22c0d92ddc66140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae728be96517630adbca51492edee075b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a8e7b87e6fcd753ce232c11088192d63e">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#ae728be96517630adbca51492edee075b">erase</a> (<a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#aa5bea87e824b662fd8dd7ea77b7c62fb">const_iterator</a> first, <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#aa5bea87e824b662fd8dd7ea77b7c62fb">const_iterator</a> last)</td></tr>
<tr class="memdesc:ae728be96517630adbca51492edee075b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all elements in the range [first, last) from the sequence.  <a href="#ae728be96517630adbca51492edee075b">More...</a><br /></td></tr>
<tr class="separator:ae728be96517630adbca51492edee075b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab12b2648d7c59d6d64d11c3d39c19626"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#ab12b2648d7c59d6d64d11c3d39c19626">push_back</a> (T const &amp;value)</td></tr>
<tr class="memdesc:ab12b2648d7c59d6d64d11c3d39c19626"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructs an object at end().  <a href="#ab12b2648d7c59d6d64d11c3d39c19626">More...</a><br /></td></tr>
<tr class="separator:ab12b2648d7c59d6d64d11c3d39c19626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00ab9e638a6c23497d179d5b55726bce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a00ab9e638a6c23497d179d5b55726bce">push_back</a> (T &amp;&amp;value)</td></tr>
<tr class="memdesc:a00ab9e638a6c23497d179d5b55726bce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructs an object at end().  <a href="#a00ab9e638a6c23497d179d5b55726bce">More...</a><br /></td></tr>
<tr class="separator:a00ab9e638a6c23497d179d5b55726bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab62697d12cacfd16d71de0f6b49e0905"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:ab62697d12cacfd16d71de0f6b49e0905"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#ab62697d12cacfd16d71de0f6b49e0905">emplace_back</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:ab62697d12cacfd16d71de0f6b49e0905"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward constructs an object at end().  <a href="#ab62697d12cacfd16d71de0f6b49e0905">More...</a><br /></td></tr>
<tr class="separator:ab62697d12cacfd16d71de0f6b49e0905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4edcf18daae0e14f87694850741b0ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#ab4edcf18daae0e14f87694850741b0ba">pop_back</a> ()</td></tr>
<tr class="memdesc:ab4edcf18daae0e14f87694850741b0ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the object at end() - 1.  <a href="#ab4edcf18daae0e14f87694850741b0ba">More...</a><br /></td></tr>
<tr class="separator:ab4edcf18daae0e14f87694850741b0ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af48db19e362b24b4edea9c767d9b9a6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#af48db19e362b24b4edea9c767d9b9a6b">push_front</a> (const T &amp;value)</td></tr>
<tr class="memdesc:af48db19e362b24b4edea9c767d9b9a6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructs an object at begin().  <a href="#af48db19e362b24b4edea9c767d9b9a6b">More...</a><br /></td></tr>
<tr class="separator:af48db19e362b24b4edea9c767d9b9a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae09bb21d03f538faddbafd9dff17f76a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#ae09bb21d03f538faddbafd9dff17f76a">push_front</a> (T &amp;&amp;value)</td></tr>
<tr class="memdesc:ae09bb21d03f538faddbafd9dff17f76a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructs an object at begin().  <a href="#ae09bb21d03f538faddbafd9dff17f76a">More...</a><br /></td></tr>
<tr class="separator:ae09bb21d03f538faddbafd9dff17f76a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cc0a741cb1a84dc8944f0199fc7f138"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a1cc0a741cb1a84dc8944f0199fc7f138"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a1cc0a741cb1a84dc8944f0199fc7f138">emplace_front</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a1cc0a741cb1a84dc8944f0199fc7f138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward constructs an object at begin().  <a href="#a1cc0a741cb1a84dc8944f0199fc7f138">More...</a><br /></td></tr>
<tr class="separator:a1cc0a741cb1a84dc8944f0199fc7f138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa947de9ebc3fcdc3f26a8a7734caf620"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#aa947de9ebc3fcdc3f26a8a7734caf620">pop_front</a> ()</td></tr>
<tr class="memdesc:aa947de9ebc3fcdc3f26a8a7734caf620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the object at begin().  <a href="#aa947de9ebc3fcdc3f26a8a7734caf620">More...</a><br /></td></tr>
<tr class="separator:aa947de9ebc3fcdc3f26a8a7734caf620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64b70861dbe791f5f7ca4d95ec4677af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a64b70861dbe791f5f7ca4d95ec4677af">resize</a> (<a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a86c01867901b5c16949ba2377423b96f">size_type</a> count)</td></tr>
<tr class="memdesc:a64b70861dbe791f5f7ca4d95ec4677af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the seqeuence to the specified size, default construct any elements above the current size.  <a href="#a64b70861dbe791f5f7ca4d95ec4677af">More...</a><br /></td></tr>
<tr class="separator:a64b70861dbe791f5f7ca4d95ec4677af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad9ed5036588c395ba672d1eb9cd9a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a3ad9ed5036588c395ba672d1eb9cd9a1">resize</a> (<a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a86c01867901b5c16949ba2377423b96f">size_type</a> count, <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a6f4abae8bb6c60675011914c5c4c1f40">value_type</a> const &amp;value)</td></tr>
<tr class="memdesc:a3ad9ed5036588c395ba672d1eb9cd9a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the seqeuence to the specified size, copy construct any elements from value above the current size.  <a href="#a3ad9ed5036588c395ba672d1eb9cd9a1">More...</a><br /></td></tr>
<tr class="separator:a3ad9ed5036588c395ba672d1eb9cd9a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d64a537fb34ae7dbb94e6c5f1be94e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a9d64a537fb34ae7dbb94e6c5f1be94e6">swap</a> (<a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">segmented_tree_seq</a> &amp;other) noexcept(               !element_traits::propagate_on_container_swap::value||               segmented_tree_seq_detail::is_nothrow_swappable&lt; <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#abe7ffc37700e6030feaca9d5717848f7">allocator_type</a> &gt;::value)</td></tr>
<tr class="memdesc:a9d64a537fb34ae7dbb94e6c5f1be94e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents *this with the specified sequence.  <a href="#a9d64a537fb34ae7dbb94e6c5f1be94e6">More...</a><br /></td></tr>
<tr class="separator:a9d64a537fb34ae7dbb94e6c5f1be94e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6cc6aad58b42326880c8b21ec2ce0ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#aa6cc6aad58b42326880c8b21ec2ce0ec">remove</a> (const T &amp;value)</td></tr>
<tr class="memdesc:aa6cc6aad58b42326880c8b21ec2ce0ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements matching the specified value.  <a href="#aa6cc6aad58b42326880c8b21ec2ce0ec">More...</a><br /></td></tr>
<tr class="separator:aa6cc6aad58b42326880c8b21ec2ce0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b17ba406c5003db49ddcef9817e5f3b"><td class="memTemplParams" colspan="2">template&lt;class UnaryPredicate &gt; </td></tr>
<tr class="memitem:a5b17ba406c5003db49ddcef9817e5f3b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a5b17ba406c5003db49ddcef9817e5f3b">remove_if</a> (UnaryPredicate p)</td></tr>
<tr class="memdesc:a5b17ba406c5003db49ddcef9817e5f3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements matching the specified predicate.  <a href="#a5b17ba406c5003db49ddcef9817e5f3b">More...</a><br /></td></tr>
<tr class="separator:a5b17ba406c5003db49ddcef9817e5f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf500df64ceeeacca8edee2b88c4a713"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#adf500df64ceeeacca8edee2b88c4a713">reverse</a> ()</td></tr>
<tr class="memdesc:adf500df64ceeeacca8edee2b88c4a713"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the sequence.  <a href="#adf500df64ceeeacca8edee2b88c4a713">More...</a><br /></td></tr>
<tr class="separator:adf500df64ceeeacca8edee2b88c4a713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a566cb1eec46bf15252beca7d80f3bb94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a566cb1eec46bf15252beca7d80f3bb94">unique</a> ()</td></tr>
<tr class="memdesc:a566cb1eec46bf15252beca7d80f3bb94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all consecutive duplicate elements from the sequence.  <a href="#a566cb1eec46bf15252beca7d80f3bb94">More...</a><br /></td></tr>
<tr class="separator:a566cb1eec46bf15252beca7d80f3bb94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ecfdc556ed2ddd1f7c1c6330a1daad0"><td class="memTemplParams" colspan="2">template&lt;class BinaryPredicate &gt; </td></tr>
<tr class="memitem:a9ecfdc556ed2ddd1f7c1c6330a1daad0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a9ecfdc556ed2ddd1f7c1c6330a1daad0">unique</a> (BinaryPredicate p)</td></tr>
<tr class="memdesc:a9ecfdc556ed2ddd1f7c1c6330a1daad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all consecutive duplicate elements from the sequence using the specified predicate.  <a href="#a9ecfdc556ed2ddd1f7c1c6330a1daad0">More...</a><br /></td></tr>
<tr class="separator:a9ecfdc556ed2ddd1f7c1c6330a1daad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b2d6ad9a82ad1f4a8fb828291b114e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a25b2d6ad9a82ad1f4a8fb828291b114e">sort</a> ()</td></tr>
<tr class="memdesc:a25b2d6ad9a82ad1f4a8fb828291b114e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stable sorts the sequence.  <a href="#a25b2d6ad9a82ad1f4a8fb828291b114e">More...</a><br /></td></tr>
<tr class="separator:a25b2d6ad9a82ad1f4a8fb828291b114e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c094b10ba79e30721a9f56b72ac9926"><td class="memTemplParams" colspan="2">template&lt;class Compare &gt; </td></tr>
<tr class="memitem:a2c094b10ba79e30721a9f56b72ac9926"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a2c094b10ba79e30721a9f56b72ac9926">sort</a> (Compare comp)</td></tr>
<tr class="memdesc:a2c094b10ba79e30721a9f56b72ac9926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stable sort the sequence using the specified predicate.  <a href="#a2c094b10ba79e30721a9f56b72ac9926">More...</a><br /></td></tr>
<tr class="separator:a2c094b10ba79e30721a9f56b72ac9926"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename Allocator, std::size_t segment_target, std::size_t base_target&gt;<br />
class boost::container::segmented_tree_seq&lt; T, Allocator, segment_target, base_target &gt;</h3>

<p>A segmented_tree_seq is a sequence container that provides efficient random access insert and erase. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of object to be stored </td></tr>
    <tr><td class="paramname">Allocator</td><td>The type of the allocator used for all memory management </td></tr>
    <tr><td class="paramname">segment_target</td><td>Size in bytes to try to use for object nodes </td></tr>
    <tr><td class="paramname">base_target</td><td>Size in bytes to try to use for index nodes </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a9cbf9f31953af034e5f31ce829e13a43"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::<a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">segmented_tree_seq</a> </td>
          <td>(</td>
          <td class="paramtype">Allocator const &amp;&#160;</td>
          <td class="paramname"><em>alloc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty sequence using the specified allocator. </p>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

</div>
</div>
<a class="anchor" id="a30d319a4a25a29e39e523b9ec9a31b5e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::<a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">segmented_tree_seq</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructs an empty sequence. </p>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

</div>
</div>
<a class="anchor" id="a7944397dde9f0b1959bf67307fb8d44e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::<a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">segmented_tree_seq</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a86c01867901b5c16949ba2377423b96f">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Allocator const &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a count size sequence using the specified allocator, each element copy constructed from value. </p>
<dl class="section user"><dt>Complexity</dt><dd>NlogN, where N is count. </dd></dl>

</div>
</div>
<a class="anchor" id="ac2512f106644d962f4b50af2b7358303"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::<a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">segmented_tree_seq</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a86c01867901b5c16949ba2377423b96f">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Allocator const &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a count size sequence using the specified allocator, each element default constructed. </p>
<dl class="section user"><dt>Complexity</dt><dd>NlogN, where N is count. </dd></dl>

</div>
</div>
<a class="anchor" id="a9e208324e2ac8d5a0fe3181ece537590"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<div class="memtemplate">
template&lt;class InputIt , typename  = typename std::iterator_traits&lt;InputIt&gt;::pointer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::<a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">segmented_tree_seq</a> </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Allocator const &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty sequence using the specified allocator, and inserts elements from the range [first, last). </p>
<dl class="section user"><dt>Complexity</dt><dd>NlogN, where N is the size of the range. </dd></dl>

</div>
</div>
<a class="anchor" id="a972447e632b0a7784951359da5f7fbe7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::<a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">segmented_tree_seq</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructs a sequence. </p>
<dl class="section user"><dt>Complexity</dt><dd>NlogN, where N is other.size(). </dd></dl>

</div>
</div>
<a class="anchor" id="a44d7eaef0f0f98e055896122c4d59a71"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::<a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">segmented_tree_seq</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Allocator const &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructs a sequence using the specified allocator. </p>
<dl class="section user"><dt>Complexity</dt><dd>NlogN, where N is other.size(). </dd></dl>

</div>
</div>
<a class="anchor" id="afc84aeec616e82babdaa7b4875c30186"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::<a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">segmented_tree_seq</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructs a sequence. </p>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

</div>
</div>
<a class="anchor" id="a16bf8a9a04f3377115bca46e3339dc16"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::<a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">segmented_tree_seq</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Allocator const &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructs a sequence using the specified allocator. </p>
<dl class="section user"><dt>Complexity</dt><dd>Constant if alloc compares equal to other's allocator. NlogN, where N is other.size() otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="abf01f7c60dddce42f06ad18e02a3a1f6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::<a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">segmented_tree_seq</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Allocator const &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty sequence using the specified allocator, and inserts elements from init. </p>
<dl class="section user"><dt>Complexity</dt><dd>NlogN, where N is init.size(). </dd></dl>

</div>
</div>
<a class="anchor" id="a150e6370398c73554f47a8feedc064dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::~<a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">segmented_tree_seq</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructs the sequence releasing all memory. </p>
<dl class="section user"><dt>Complexity</dt><dd>Linear in size(). </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a58a00e1275976493e0d9de2a583b4d9f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a86c01867901b5c16949ba2377423b96f">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns the sequence to count elements copy constructed from value. </p>
<dl class="section user"><dt>Complexity</dt><dd>Linear in the minimum of size() and count, plus MlogN, where M is the difference of size() and count, and N is the maximum of size() and count.</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Invalidates all iterators.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>Basic. </dd></dl>

</div>
</div>
<a class="anchor" id="a00a489f29272a6c8ab03b87ec38c891b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<div class="memtemplate">
template&lt;class InputIt , typename  = typename std::iterator_traits&lt;InputIt&gt;::pointer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>source_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>source_last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns the sequence to the elements copy constructed from the range [first, last). </p>
<dl class="section user"><dt>Complexity</dt><dd>Linear in the minimum of size() and the size of the range, plus MlogN, where M is the difference of size() and the size of the range, and N is the maximum of size() and the size of the range.</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Invalidates all iterators.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>Basic. </dd></dl>

</div>
</div>
<a class="anchor" id="a3f0d654ae1726a17e7c548ff98c85bce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns the sequence to the elements of the specified initializer_list. </p>
<dl class="section user"><dt>Complexity</dt><dd>Linear in the minimum of size() and ilist.size(), plus MlogN, where M is the difference of size() and ilist.size(), and N is the maximum of size() and ilist.size().</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Invalidates all iterators.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>Basic. </dd></dl>

</div>
</div>
<a class="anchor" id="a583b33cf66e8479658583accd35f196e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a5c080ce5696a13d4496dfa62f19f53ce">reference</a> <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a86c01867901b5c16949ba2377423b96f">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference for the object located at the index pos. </p>
<dl class="section user"><dt>Complexity</dt><dd>Logarithmic in size().</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Iterators are not invalidated.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>Strong. </dd></dl>

</div>
</div>
<a class="anchor" id="a3848a61f645d90a0d0604b793ad5e35f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#acbcf64eda8f7e97d36f972cf63fcca6f">const_reference</a> <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a86c01867901b5c16949ba2377423b96f">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const_reference for the object located at the specified index pos. </p>
<dl class="section user"><dt>Complexity</dt><dd>Logarithmic in size().</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Iterators are not invalidated.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>Strong. </dd></dl>

</div>
</div>
<a class="anchor" id="a854fbfddb195e01e6606cce27387f7bb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a5c080ce5696a13d4496dfa62f19f53ce">reference</a> <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference for the object located at the index size() - 1. </p>
<dl class="section user"><dt>Complexity</dt><dd>Logarithmic in size().</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Iterators are not invalidated.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>Strong. </dd></dl>

</div>
</div>
<a class="anchor" id="a9826fe687a13982a55b3cb022d860829"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#acbcf64eda8f7e97d36f972cf63fcca6f">const_reference</a> <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const_reference for the object located at the index size() - 1. </p>
<dl class="section user"><dt>Complexity</dt><dd>Logarithmic in size().</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Iterators are not invalidated.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>Strong. </dd></dl>

</div>
</div>
<a class="anchor" id="aa2e8c0fc6a97bb63e7c11d90c7cc270a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a8e7b87e6fcd753ce232c11088192d63e">iterator</a> <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator for the index 0. </p>
<dl class="section user"><dt>Complexity</dt><dd>Logarithmic in size().</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Iterators are not invalidated.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>No-throw. </dd></dl>

</div>
</div>
<a class="anchor" id="a14e8f1484e21762efa317659d16914c4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#aa5bea87e824b662fd8dd7ea77b7c62fb">const_iterator</a> <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const_iterator for the index 0. </p>
<dl class="section user"><dt>Complexity</dt><dd>Logarithmic in size().</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Iterators are not invalidated.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>No-throw. </dd></dl>

</div>
</div>
<a class="anchor" id="ac091db2869dcfb5fd6028e67e33b85ee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#aa5bea87e824b662fd8dd7ea77b7c62fb">const_iterator</a> <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const_iterator for the index 0. </p>
<dl class="section user"><dt>Complexity</dt><dd>Logarithmic in size().</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Iterators are not invalidated.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>No-throw. </dd></dl>

</div>
</div>
<a class="anchor" id="aa063813ca250438066c4b00db1c6360f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#aa5bea87e824b662fd8dd7ea77b7c62fb">const_iterator</a> <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const_iterator for the index size(). </p>
<dl class="section user"><dt>Complexity</dt><dd>Logarithmic in size().</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Iterators are not invalidated.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>No-throw. </dd></dl>

</div>
</div>
<a class="anchor" id="a0f9dc208a664f0753a148e93f68a7f39"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all elements from the sequence. </p>
<dl class="section user"><dt>Complexity</dt><dd>Linear in size().</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Invalidates all iterators.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>No-throw. </dd></dl>

</div>
</div>
<a class="anchor" id="a415ac3567b9c24a6e433e1ca41bd9089"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#aa5bea87e824b662fd8dd7ea77b7c62fb">const_iterator</a> <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::cpenultimate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const_iterator to the index size() - 1. </p>
<dl class="section user"><dt>Complexity</dt><dd>Logarithmic in size().</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Iterators are not invalidated.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>No-throw.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Non-standard extension. </dd></dl>

</div>
</div>
<a class="anchor" id="a004d94988016bcbeab7a52088649b9fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a00c5fb657f549f439cb7401c9de8c083">const_reverse_iterator</a> <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const_reverse_iterator for the index size(). </p>
<dl class="section user"><dt>Complexity</dt><dd>Logarithmic in size().</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Iterators are not invalidated.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>No-throw. </dd></dl>

</div>
</div>
<a class="anchor" id="afd4389882226b3cae4fee967e4537fc1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a00c5fb657f549f439cb7401c9de8c083">const_reverse_iterator</a> <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const_reverse_iterator for the index 0. </p>
<dl class="section user"><dt>Complexity</dt><dd>Logarithmic in size().</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Iterators are not invalidated.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>No-throw. </dd></dl>

</div>
</div>
<a class="anchor" id="a2d6d23ad18f64aafdf5f9bc37a7971ae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a8e7b87e6fcd753ce232c11088192d63e">iterator</a> <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#aa5bea87e824b662fd8dd7ea77b7c62fb">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forward constructs an object at the specified position. </p>
<dl class="section user"><dt>Complexity</dt><dd>Logarithmic in size().</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Invalidates all iterators.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>Strong. </dd></dl>

</div>
</div>
<a class="anchor" id="ab62697d12cacfd16d71de0f6b49e0905"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::emplace_back </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forward constructs an object at end(). </p>
<dl class="section user"><dt>Complexity</dt><dd>Logarithmic in size().</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Invalidates all iterators.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>Strong. </dd></dl>

</div>
</div>
<a class="anchor" id="a1cc0a741cb1a84dc8944f0199fc7f138"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::emplace_front </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forward constructs an object at begin(). </p>
<dl class="section user"><dt>Complexity</dt><dd>Logarithmic in size().</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Invalidates all iterators.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>Strong. </dd></dl>

</div>
</div>
<a class="anchor" id="ab7f9b817e2cc7924a450cb61054e1146"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the sequence is empty, false otherwise. </p>
<dl class="section user"><dt>Complexity</dt><dd>Constant.</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Iterators are not invalidated.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>No-throw. </dd></dl>

</div>
</div>
<a class="anchor" id="abcf454cb608ccba75ceff1a78e82a1a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a8e7b87e6fcd753ce232c11088192d63e">iterator</a> <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator for the index size(). </p>
<dl class="section user"><dt>Complexity</dt><dd>Logarithmic in size().</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Iterators are not invalidated.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>No-throw. </dd></dl>

</div>
</div>
<a class="anchor" id="a342650aa64a6a2e1b3f6eae4a3343149"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#aa5bea87e824b662fd8dd7ea77b7c62fb">const_iterator</a> <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const_iterator for the index size(). </p>
<dl class="section user"><dt>Complexity</dt><dd>Logarithmic in size().</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Iterators are not invalidated.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>No-throw. </dd></dl>

</div>
</div>
<a class="anchor" id="a6307735b88b83ab9c22c0d92ddc66140"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a8e7b87e6fcd753ce232c11088192d63e">iterator</a> <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#aa5bea87e824b662fd8dd7ea77b7c62fb">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the object at the specified position from the sequence. </p>
<dl class="section user"><dt>Complexity</dt><dd>Logarithmic in size().</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Invalidates all iterators.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>Strong. </dd></dl>

</div>
</div>
<a class="anchor" id="ae728be96517630adbca51492edee075b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a8e7b87e6fcd753ce232c11088192d63e">iterator</a> <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#aa5bea87e824b662fd8dd7ea77b7c62fb">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#aa5bea87e824b662fd8dd7ea77b7c62fb">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove all elements in the range [first, last) from the sequence. </p>
<dl class="section user"><dt>Complexity</dt><dd>MlogN, where M is the size of the range, and N is size().</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Invalidates all iterators.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>Basic. </dd></dl>

</div>
</div>
<a class="anchor" id="a6f68452c5f0befb302df3ce8c35c273d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a5c080ce5696a13d4496dfa62f19f53ce">reference</a> <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference for the object located at the index 0. </p>
<dl class="section user"><dt>Complexity</dt><dd>Logarithmic in size().</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Iterators are not invalidated.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>Strong. </dd></dl>

</div>
</div>
<a class="anchor" id="a82e2b733fce99c20b31f29dd44150ce1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#acbcf64eda8f7e97d36f972cf63fcca6f">const_reference</a> <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const_reference for the object located at the index 0. </p>
<dl class="section user"><dt>Complexity</dt><dd>Logarithmic in size().</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Iterators are not invalidated.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>Strong. </dd></dl>

</div>
</div>
<a class="anchor" id="a1e439edbba096a657869aac8c44577e8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#abe7ffc37700e6030feaca9d5717848f7">allocator_type</a> <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of the allocator for the sequence. </p>
<dl class="section user"><dt>Complexity</dt><dd>Constant.</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Iterators are not invalidated.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>No-throw. </dd></dl>

</div>
</div>
<a class="anchor" id="a0f1f90b102dd7dbe12ab197ac145abee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a86c01867901b5c16949ba2377423b96f">size_type</a> <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::height </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the height of the tree. </p>
<dl class="section user"><dt>Complexity</dt><dd>Constant.</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Iterators are not invalidated.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>No-throw.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Non-standard extension. </dd></dl>

</div>
</div>
<a class="anchor" id="a50862ae43a026cb5369070d0cdad8dc7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a86c01867901b5c16949ba2377423b96f">size_type</a> <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::index_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a8e7b87e6fcd753ce232c11088192d63e">iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the specified iterator. </p>
<dl class="section user"><dt>Complexity</dt><dd>Constant.</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Iterators are not invalidated.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>No-throw.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Non-standard extension. </dd></dl>

</div>
</div>
<a class="anchor" id="a37ef0b30f070fe072c85e818debb5a44"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a86c01867901b5c16949ba2377423b96f">size_type</a> <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::index_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#aa5bea87e824b662fd8dd7ea77b7c62fb">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the specified const_iterator. </p>
<dl class="section user"><dt>Complexity</dt><dd>Constant.</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Iterators are not invalidated.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>No-throw.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Non-standard extension. </dd></dl>

</div>
</div>
<a class="anchor" id="ae1f4986b73cb15f68d473c3d1f12f399"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a8e7b87e6fcd753ce232c11088192d63e">iterator</a> <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#aa5bea87e824b662fd8dd7ea77b7c62fb">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructs an object at the specified position. </p>
<dl class="section user"><dt>Complexity</dt><dd>Logarithmic in size().</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Invalidates all iterators.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>Strong. </dd></dl>

</div>
</div>
<a class="anchor" id="a61f6a4ad55d3cdfe8f907ea7b9b1cba6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a8e7b87e6fcd753ce232c11088192d63e">iterator</a> <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#aa5bea87e824b662fd8dd7ea77b7c62fb">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move construct an object at the specified position. </p>
<dl class="section user"><dt>Complexity</dt><dd>Logarithmic in size().</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Invalidates all iterators.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>Strong. </dd></dl>

</div>
</div>
<a class="anchor" id="a9176dfa87acd53a3485bec3733ae368a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a8e7b87e6fcd753ce232c11088192d63e">iterator</a> <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#aa5bea87e824b662fd8dd7ea77b7c62fb">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a86c01867901b5c16949ba2377423b96f">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy construct count elements at the specified position. </p>
<dl class="section user"><dt>Complexity</dt><dd>MlogN, where M is count, and N is the maximum of size() and count.</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Invalidates all iterators.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>Basic. </dd></dl>

</div>
</div>
<a class="anchor" id="a2440645f49fee33b9104ed9e78744795"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<div class="memtemplate">
template&lt;class InputIt , typename  = typename std::iterator_traits&lt;InputIt&gt;::pointer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a8e7b87e6fcd753ce232c11088192d63e">iterator</a> <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#aa5bea87e824b662fd8dd7ea77b7c62fb">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructs all elements in the range [first, last) at the specified position. </p>
<dl class="section user"><dt>Complexity</dt><dd>MlogN, where M is the size of the range, and N is the maximum of size() and the size of the range.</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Invalidates all iterators.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>Basic. </dd></dl>

</div>
</div>
<a class="anchor" id="ac9d25190e454da4d597f9ee05feca343"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a8e7b87e6fcd753ce232c11088192d63e">iterator</a> <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#aa5bea87e824b662fd8dd7ea77b7c62fb">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ilist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructs all elements in the specified initializer_list at the specified position. </p>
<dl class="section user"><dt>Complexity</dt><dd>MlogN, where M is ilist.size(), and N is the maximum of size() and ilist.size().</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Invalidates all iterators.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>Basic. </dd></dl>

</div>
</div>
<a class="anchor" id="a7c13c5039297dcf513a6276652f00abf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a86c01867901b5c16949ba2377423b96f">size_type</a> <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum count of elements able to be stored in the sequence. </p>
<dl class="section user"><dt>Complexity</dt><dd>Constant.</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Iterators are not invalidated.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>No-throw. </dd></dl>

</div>
</div>
<a class="anchor" id="a5db65e75657ba3ea2f67121cf0d25f2e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a8e7b87e6fcd753ce232c11088192d63e">iterator</a> <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::nth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a86c01867901b5c16949ba2377423b96f">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator for the index pos. </p>
<dl class="section user"><dt>Complexity</dt><dd>Logarithmic in size().</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Iterators are not invalidated.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>No-throw.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Non-standard extension.</dd>
<dd>
This member function is more efficient than calling begin() and advancing. </dd></dl>

</div>
</div>
<a class="anchor" id="a29554e93abc87ad6a98a9da53d2bb84b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#aa5bea87e824b662fd8dd7ea77b7c62fb">const_iterator</a> <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::nth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a86c01867901b5c16949ba2377423b96f">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const_iterator for the index pos. </p>
<dl class="section user"><dt>Complexity</dt><dd>Logarithmic in size().</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Iterators are not invalidated.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>No-throw.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Non-standard extension.</dd>
<dd>
This member function is more efficient than calling begin() and advancing. </dd></dl>

</div>
</div>
<a class="anchor" id="a68f6b7b84d906997c0dfefcaf4324f4d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">segmented_tree_seq</a>&amp; <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assigns a sequence. </p>
<dl class="section user"><dt>Complexity</dt><dd>Linear in the minimum of size() and other.size(), plus MlogN, where M is the difference of size() and other.size(), and N is the maximum of size() and other.size().</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Invalidates all iterators.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>Basic. </dd></dl>

</div>
</div>
<a class="anchor" id="a920e7ded8ef46598f63a1220ae1c452d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">segmented_tree_seq</a>&amp; <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assigns a sequence. </p>
<dl class="section user"><dt>Complexity</dt><dd>Linear in size() if the allocator propagates on move assignment or the sequence's allocator compares equal to other's allocator. Linear in the minimum of size() and other.size(), plus MlogN, where M is the difference of size() and other.size(), and N is the maximum of size() and other.size() otherwise.</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>No iterators are invalidated if the allocator propagates on move assignment or the sequence's allocator compares equal to other's allocator. Invalidates all iterators otherwise.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>No-throw if the allocator propagates on move assignment or the sequence's allocator compares equal to other's allocator. Basic otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a26dd6958e87d105be3081fc529dc6db5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">segmented_tree_seq</a>&amp; <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns the sequence to count elements copy constructed from value. </p>
<dl class="section user"><dt>Complexity</dt><dd>Linear in the minimum of size() and ilist.size(), plus MlogN, where M is the difference of size() and ilist.size(), and N is the maximum of size() and ilist.size().</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Invalidates all iterators.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>Basic. </dd></dl>

</div>
</div>
<a class="anchor" id="ab26b6812d0b9c99ae1275c8baed39fe4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a5c080ce5696a13d4496dfa62f19f53ce">reference</a> <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a86c01867901b5c16949ba2377423b96f">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference for the object located at the specified index pos. </p>
<dl class="section user"><dt>Complexity</dt><dd>Logarithmic in size().</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Iterators are not invalidated.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>Strong. </dd></dl>

</div>
</div>
<a class="anchor" id="a8eed3246a332eef3c13a28fc0d138dd0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#acbcf64eda8f7e97d36f972cf63fcca6f">const_reference</a> <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a86c01867901b5c16949ba2377423b96f">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const_reference for the object located at the specified index pos. </p>
<dl class="section user"><dt>Complexity</dt><dd>Logarithmic in size().</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Iterators are not invalidated.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>Strong. </dd></dl>

</div>
</div>
<a class="anchor" id="a67db6490da979e73b6f5ffe02ec53bdb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a8e7b87e6fcd753ce232c11088192d63e">iterator</a> <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::penultimate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the index size() - 1. </p>
<dl class="section user"><dt>Complexity</dt><dd>Logarithmic in size().</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Iterators are not invalidated.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>No-throw.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Non-standard extension. </dd></dl>

</div>
</div>
<a class="anchor" id="a319da7c983b0d4bcc7f1e8eb3511f82b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#aa5bea87e824b662fd8dd7ea77b7c62fb">const_iterator</a> <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::penultimate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const_iterator to the index size() - 1. </p>
<dl class="section user"><dt>Complexity</dt><dd>Logarithmic in size().</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Iterators are not invalidated.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>No-throw.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Non-standard extension. </dd></dl>

</div>
</div>
<a class="anchor" id="ab4edcf18daae0e14f87694850741b0ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the object at end() - 1. </p>
<dl class="section user"><dt>Complexity</dt><dd>Logarithmic in size().</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Invalidates all iterators.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>Strong. </dd></dl>

</div>
</div>
<a class="anchor" id="aa947de9ebc3fcdc3f26a8a7734caf620"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::pop_front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the object at begin(). </p>
<dl class="section user"><dt>Complexity</dt><dd>Logarithmic in size().</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Invalidates all iterators.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>Strong. </dd></dl>

</div>
</div>
<a class="anchor" id="ab12b2648d7c59d6d64d11c3d39c19626"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructs an object at end(). </p>
<dl class="section user"><dt>Complexity</dt><dd>Logarithmic in size().</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Invalidates all iterators.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>Strong. </dd></dl>

</div>
</div>
<a class="anchor" id="a00ab9e638a6c23497d179d5b55726bce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructs an object at end(). </p>
<dl class="section user"><dt>Complexity</dt><dd>Logarithmic in size().</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Invalidates all iterators.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>Strong. </dd></dl>

</div>
</div>
<a class="anchor" id="af48db19e362b24b4edea9c767d9b9a6b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::push_front </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructs an object at begin(). </p>
<dl class="section user"><dt>Complexity</dt><dd>Logarithmic in size().</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Invalidates all iterators.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>Strong. </dd></dl>

</div>
</div>
<a class="anchor" id="ae09bb21d03f538faddbafd9dff17f76a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::push_front </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructs an object at begin(). </p>
<dl class="section user"><dt>Complexity</dt><dd>Logarithmic in size().</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Invalidates all iterators.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>Strong. </dd></dl>

</div>
</div>
<a class="anchor" id="a9c505a59a968f6935c082a7978416da4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a61182eb9ea0625c4c6f2e43dd316e0f5">reverse_iterator</a> <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse_iterator for the index size(). </p>
<dl class="section user"><dt>Complexity</dt><dd>Logarithmic in size().</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Iterators are not invalidated.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>No-throw. </dd></dl>

</div>
</div>
<a class="anchor" id="a23e29690e43f7dd6a5d1c32ddc3f7406"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a00c5fb657f549f439cb7401c9de8c083">const_reverse_iterator</a> <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const_reverse_iterator for the index size(). </p>
<dl class="section user"><dt>Complexity</dt><dd>Logarithmic in size().</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Iterators are not invalidated.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>No-throw. </dd></dl>

</div>
</div>
<a class="anchor" id="aa6cc6aad58b42326880c8b21ec2ce0ec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all elements matching the specified value. </p>
<dl class="section user"><dt>Complexity</dt><dd>Logarithmic in size().</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Invalidates all iterators.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>Basic. </dd></dl>

</div>
</div>
<a class="anchor" id="a5b17ba406c5003db49ddcef9817e5f3b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<div class="memtemplate">
template&lt;class UnaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::remove_if </td>
          <td>(</td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all elements matching the specified predicate. </p>
<dl class="section user"><dt>Complexity</dt><dd>Linear in size().</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Invalidates all iterators.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>Basic. </dd></dl>

</div>
</div>
<a class="anchor" id="a14ef8f17fb622f5f9cd1e085c041d165"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a61182eb9ea0625c4c6f2e43dd316e0f5">reverse_iterator</a> <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse_iterator for the index 0. </p>
<dl class="section user"><dt>Complexity</dt><dd>Logarithmic in size().</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Iterators are not invalidated.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>No-throw. </dd></dl>

</div>
</div>
<a class="anchor" id="aa6c53450a3514d9186071d205a44449d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a00c5fb657f549f439cb7401c9de8c083">const_reverse_iterator</a> <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const_reverse_iterator for the index 0. </p>
<dl class="section user"><dt>Complexity</dt><dd>Logarithmic in size().</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Iterators are not invalidated.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>No-throw. </dd></dl>

</div>
</div>
<a class="anchor" id="a64b70861dbe791f5f7ca4d95ec4677af"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a86c01867901b5c16949ba2377423b96f">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the seqeuence to the specified size, default construct any elements above the current size. </p>
<dl class="section user"><dt>Complexity</dt><dd>MlogN, where M is the difference of size() and count, and N is the max of size() and count.</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Invalidates all iterators.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>Strong. </dd></dl>

</div>
</div>
<a class="anchor" id="a3ad9ed5036588c395ba672d1eb9cd9a1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a86c01867901b5c16949ba2377423b96f">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a6f4abae8bb6c60675011914c5c4c1f40">value_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the seqeuence to the specified size, copy construct any elements from value above the current size. </p>
<dl class="section user"><dt>Complexity</dt><dd>MlogN, where M is the difference of size() and count, and N is the max of size() and count.</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Invalidates all iterators.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>Basic. </dd></dl>

</div>
</div>
<a class="anchor" id="adf500df64ceeeacca8edee2b88c4a713"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::reverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses the sequence. </p>
<dl class="section user"><dt>Complexity</dt><dd>Linear in size().</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Iterators are not invalidated, but reflect the change in ordering.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>Basic. </dd></dl>

</div>
</div>
<a class="anchor" id="a933ca7e0417f7d9819a9fb5b23dc4f21"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html#a86c01867901b5c16949ba2377423b96f">size_type</a> <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the count of elements stored in the sequence. </p>
<dl class="section user"><dt>Complexity</dt><dd>Constant.</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Iterators are not invalidated.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>No-throw. </dd></dl>

</div>
</div>
<a class="anchor" id="a25b2d6ad9a82ad1f4a8fb828291b114e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::sort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stable sorts the sequence. </p>
<dl class="section user"><dt>Complexity</dt><dd>NlogN, where N is size().</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Iterators are not invalidated, but reflect the change in ordering.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>Basic. </dd></dl>

</div>
</div>
<a class="anchor" id="a2c094b10ba79e30721a9f56b72ac9926"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<div class="memtemplate">
template&lt;class Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::sort </td>
          <td>(</td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stable sort the sequence using the specified predicate. </p>
<dl class="section user"><dt>Complexity</dt><dd>NlogN, where N is size().</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Iterators are not invalidated, but reflect the change in ordering.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>Basic. </dd></dl>

</div>
</div>
<a class="anchor" id="a9d64a537fb34ae7dbb94e6c5f1be94e6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents *this with the specified sequence. </p>
<dl class="section user"><dt>Complexity</dt><dd>Constant.</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Every iterator referring to an element in one container before the swap shall refer to the same element in the other container after the swap.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>No-throw if the allocator propagates on swap or the allocator doesn't throw on swap. Strong otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a566cb1eec46bf15252beca7d80f3bb94"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::unique </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all consecutive duplicate elements from the sequence. </p>
<dl class="section user"><dt>Complexity</dt><dd>Linear in size().</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Invalidates all iterators.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>Basic. </dd></dl>

</div>
</div>
<a class="anchor" id="a9ecfdc556ed2ddd1f7c1c6330a1daad0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , std::size_t segment_target, std::size_t base_target&gt; </div>
<div class="memtemplate">
template&lt;class BinaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1container_1_1segmented__tree__seq.html">boost::container::segmented_tree_seq</a>&lt; T, Allocator, segment_target, base_target &gt;::unique </td>
          <td>(</td>
          <td class="paramtype">BinaryPredicate&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all consecutive duplicate elements from the sequence using the specified predicate. </p>
<dl class="section user"><dt>Complexity</dt><dd>Linear in size().</dd></dl>
<dl class="section user"><dt>Iterator invalidation</dt><dd>Invalidates all iterators.</dd></dl>
<dl class="section user"><dt>Exception safety</dt><dd>Basic. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="segmented__tree__seq_8hpp_source.html">segmented_tree_seq.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
